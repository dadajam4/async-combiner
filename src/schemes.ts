/**
 * @private
 * Returns `true` if it is a iterable object
 **/
export const isIterableObject = (source?: any): source is object => {
  return (
    Array.isArray(source) ||
    (source &&
      typeof source === 'object' &&
      source.constructor.name === 'Object') ||
    false
  );
};

/**
 * @private
 * Value type that is allowed as the value of asynchronous process execution condition object. Types not defined here will be missing when flattened.
 */
export type AsyncCombinerConditionValue =
  | string
  | number
  | boolean
  | undefined
  | null
  | Date;

const allowdPrimitiveConditionValueTypes = [
  'string',
  'number',
  'boolean',
  'undefined',
];

/**
 * @private
 * If the passed value matches [AsyncCombinerConditionValue], it returns `true`.
 */
export function isConditionValue(
  value?: any,
): value is AsyncCombinerConditionValue {
  const type = typeof value;
  if (allowdPrimitiveConditionValueTypes.includes(type)) return true;
  if (value === null) return true;
  if (value instanceof Date) return true;
  return false;
}

/**
 * Condition source for executing asynchronous processing.
 * No information about objects generated according to this interface condition is lost.
 */
export type AsyncCombinerCondition =
  | AsyncCombinerConditionValue
  | AsyncCombinerCondition[]
  | {
      [key: string]: AsyncCombinerCondition;
    };

/**
 * In order to perform comparison process efficiently, it is an asynchronous process execution condition object that has been flat processed.
 */
export interface AsyncCombinerFlattenedCondition {
  [key: string]: AsyncCombinerConditionValue;
}

/**
 * @private
 * The asynchronous process execution condition object always takes the form of an object. If the passed condition is a primitive value, this key will be adopted as default.
 */
export const DefaultConditionName = '_async-combiner-condition_';

/** @private */
export function traverseAndFlatten(
  currentNode: any,
  result: AsyncCombinerFlattenedCondition,
  flattenedKey?: string,
) {
  // If the object should not be enumerated, cast it to an enum type
  if (isConditionValue(currentNode)) {
    currentNode = { [DefaultConditionName]: currentNode };
  }

  Object.keys(currentNode).forEach((key) => {
    let value = currentNode[key];

    let newKey: string;
    if (flattenedKey === undefined) {
      newKey = key;
    } else {
      newKey = flattenedKey + '.' + key;
    }

    if (isIterableObject(value)) {
      traverseAndFlatten(value, result, newKey);
    } else if (isConditionValue(value)) {
      if (value instanceof Date) value = value.toString();
      result[newKey] = value;
    }
  });
  return result;
}

/**
 * @private
 * The behavior is almost the same as [createCondition], but the condition object generated by this method is not lost at all.
 */
export function flattenCondition(
  condition: AsyncCombinerCondition,
): AsyncCombinerFlattenedCondition {
  const flattenedCondition: AsyncCombinerFlattenedCondition = {};
  traverseAndFlatten(condition, flattenedCondition);
  return flattenedCondition;
}

/**
 * Generate a condition object for executing asynchronous processing. At this point, constructors such as `Symbol` and `Function` are removed.
 * @param args Any free parameter
 */
export function createCondition(
  ...args: any[]
): AsyncCombinerFlattenedCondition {
  const flattenedCondition: AsyncCombinerFlattenedCondition = {};
  traverseAndFlatten(args, flattenedCondition);
  return flattenedCondition;
}

/**
 * @private
 * Returns `true` if the two flattened execution conditions are strict equal
 */
export function isSameFlattendCondition(a, b) {
  const akeys = Object.keys(a);
  const bkeys = Object.keys(b);
  if (akeys.length !== bkeys.length) return false;
  return akeys.every((key) => a[key] === b[key]);
}
